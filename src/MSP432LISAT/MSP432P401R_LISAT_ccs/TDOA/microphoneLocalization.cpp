#include <ti/sysbios/knl/Clock.h>

#include "common.h"
#include <TDOA/microphoneLocalization.h>
#include <TDOA/signalPreambleDetector.h>
#include <TDOA/signalCodeDetector.h>
#include "tdoaAlgorithm.h"

// Ease of debugging
int adcshort = ADCBUFFERSIZE_SHORT;

// ADCBuf driver structs
ADCBuf_Handle adcBuf;
ADCBuf_Params adcBufParams;
ADCBuf_Conversion conversionStruct[3];

Filter* filter = new Filter();

bool startAdcSampling = false;
int lastChannelCompleted = -1;
bool completedChannels[3] = {false, false, false};
q15_t* completedChannelBuffers[3] = {NULL, NULL, NULL};
bool shortBufferMode = false;
int pingBuffers = -1;
valin_tdoa_input lastTdoaData;
int16_t rms;
void adcBufCompletionCallback(ADCBuf_Handle handle, ADCBuf_Conversion *conversion, void *completedADCBuffer, uint32_t completedChannel);
bool allChannelsCompleted(int setCompletedChannel);

/* Set up an ADCBuf peripheral in ADCBuf_RECURRENCE_MODE_CONTINUOUS */
void initADCBuf() {
    ADCBuf_Params_init(&adcBufParams);
    adcBufParams.samplingFrequency = SAMPLE_FREQUENCY;
#if MIC_CONTINUOUS_SAMPLE == 1
    adcBufParams.recurrenceMode = ADCBuf_RECURRENCE_MODE_CONTINUOUS;
#else
    adcBufParams.recurrenceMode = ADCBuf_RECURRENCE_MODE_ONE_SHOT; // ADCBuf_RECURRENCE_MODE_CONTINUOUS;
#endif
    adcBufParams.returnMode = ADCBuf_RETURN_MODE_CALLBACK;
    adcBufParams.callbackFxn = adcBufCompletionCallback;
    adcBuf = ADCBuf_open(MIC_ADCBUF, &adcBufParams);

    /* Configure the conversion struct for 1-3 channels on same sequencer */
    setAdcBufConversionMode(true);
}

void setAdcBufConversionMode(bool shortConversion) {
    uint16_t bufferLength;
    if (shortConversion) {
        bufferLength = ADCBUFFERSIZE_SHORT;
    }else {
        bufferLength = ADCBUFFERSIZE;
    }

    conversionStruct[0].arg = NULL;
    conversionStruct[0].adcChannel = MIC_ADCBUFCHANNEL_0;
    conversionStruct[0].sampleBuffer = sampleBuffer1a;
#if MIC_CONTINUOUS_SAMPLE
    conversionStruct[0].sampleBufferTwo = sampleBuffer1b;
#endif
    conversionStruct[0].samplesRequestedCount = bufferLength;
#if NUM_ADC_CHANNELS >= 2
    conversionStruct[1].arg = NULL;
    conversionStruct[1].adcChannel = MIC_ADCBUFCHANNEL_1; // Mic 2
    conversionStruct[1].sampleBuffer = sampleBuffer2a;
#if MIC_CONTINUOUS_SAMPLE
    conversionStruct[1].sampleBufferTwo = sampleBuffer2b;
#endif
    conversionStruct[1].samplesRequestedCount = bufferLength;
#endif
#if NUM_ADC_CHANNELS >= 3
    conversionStruct[2].arg = NULL;
    conversionStruct[2].adcChannel = MIC_ADCBUFCHANNEL_2; // Mic 2
    conversionStruct[2].sampleBuffer = sampleBuffer3a;
#if MIC_CONTINUOUS_SAMPLE
    conversionStruct[2].sampleBufferTwo = sampleBuffer3b;
#endif
    conversionStruct[2].samplesRequestedCount = bufferLength;
#endif
    if (shortConversion != shortBufferMode) {
        openADCBuf();
    }
    shortBufferMode = shortConversion;
}

void openADCBuf() {
    ADCBuf_convert(adcBuf, conversionStruct, NUM_ADC_CHANNELS);
    if (!adcBuf){
        /* AdcBuf did not open correctly. */
        GPIO_write(LED_ERROR_2, 1);
        while(1);
    }
    else {
        startAdcSampling = true;
    }
}

// Not used as we have a one-shot adcbuf
void closeADCBuf() {
    // Start ADCBuf here for measurements
    ADCBuf_close(adcBuf);
}

/*
 * This function is called whenever a buffer is full. The semaphore post is awaited in the main thread.
 */
void adcBufCompletionCallback(ADCBuf_Handle handle, ADCBuf_Conversion *conversion,
    void *completedADCBuffer, uint32_t completedChannel) {
#if MSP_MIC_RAW_MODE == 0
    uint16_t *completedBuffer = (uint16_t*) completedADCBuffer;
    filter->FilterEMABuffer(completedBuffer, outputBuffer_filtered, conversion->samplesRequestedCount);

    if (shortBufferMode) {
        // Track history - short buffer only
        bool result = signalPreambleDetector(outputBuffer_filtered, &detection_history_mics[completedChannel]);
    }
    completedChannelBuffers[completedChannel] = (q15_t*) completedADCBuffer;
#endif

    if (allChannelsCompleted(completedChannel)) {
        if (!shortBufferMode) {
            // Preamble was detected, abuse ERROR LED for it.
            GPIO_toggle(LED_ERROR_2);

                // Chirp 1-2kHz, 17ms, num_chirps 2, at 39kHz
            //    q15_t chirp[] = {32767, 32333, 31009, 28777, 25649, 21673, 16928, 11533, 5642, -556, -6843, -12978, -18703, -23757, -27889, -30867, -32498, -32638, -31211, -28214, -23730, -17930, -11075, -3503, 4376, 12105, 19205, 25203, 29665, 32234, 32659, 30827, 26781, 20732, 13061, 4297, -4909, -13828, -21713, -27860, -31675, -32741, -30867, -26126, -18872, -9723, 479, 10739, 20002, 27262, 31677, 32676, 30042, 23966, 15052, 4273, -7123, -17750, -26251, -31478, -32657, -29521, -22372, -12087, -22, 12149, 22664, 29923, 32753, 30605, 23688, 12973, 89, -12912, -23872, -30891, -32668, -28768, -19747, -7108, 6924, 19775, 28995, 32737, 30149, 21601, 8671, -6109, -19734, -29328, -32767, -29181, -19203, -4909, 10581, 23764, 31550, 32005, 24874, 11719, -4373, -19486, -29818, -32657, -27128, -14510, 2007, 18086, 29371, 32684, 26958, 13635, -3638, -19962, -30568, -32226, -24283, -8968, 9169, 24571, 32372, 29975, 17973, 89, -17917, -30083, -32236, -23481, -6641, 12584, 27499, 32752, 26309, 10317, -9525, -25943, -32747, -27221, -11284, 9078, 25997, 32763, 26531, 9612, -11284, -27648, -32636, -23997, -5184, 15922, 30260, 31495, 18901, -2131, -22297, -32466, -27860, -10398, 11972, 28811, 32065, 19996, -1773, -22765, -32648, -26374, -6874, 16172, 31065, 30042, 13432, -10269, -28638, -31825, -17930, 5729, 26342, 32512, 20633, -2853, -24810, -32702, -21826, 1736, 24364, 32714, 21661, -2401, -25094, -32591, -20120, 4833, 26854, 32075, 17003, -8968, -29253, -30642, -12021, 14569, 31578, 27533, 4935, -21079, -32762, -21915, 4170, 27416, 31422, 13148, -14574, -31885, -26126, -1272, 24587, 32302, 15936, -12449, -31491, -26585, -1264, 25100, 32001, 13845, -15283, -32345, -23581, 4194, 28639, 29769, 6441, -22273, -32511, -15522, 14605, 32399, 22537, -6742, -30251, -27445, -556, 26886, 30499, 6846, -23021, -32107, -11954, 19205, 32710, 15874, -15829, -32721, -18703, 13141, 32470, 20565, -11292, -32207, -21581, 10355, 32078, 21822, -10367, -32148, -21310, 11324, 32381, 20002, -13197, -32658, -17810, 15901, 32760, 14605, -19293, -32381, -10269, 23114, 31130, 4730, -26975, -28572, 1951, 30318, 24274, -9518, -32430, -17924, 17416, 32481, 9452, -24763, -29664, 790, 30342, 23388, -11895, -32753, -13575, 22322, 30681, 941, -30016, -23353, 12768, 32755, 11047, -24831, -28814, 4447, 31972, 17792, -19747, -31302, -1407, 30396, 21583, -16246, -32183, -4475, 29364, 23023, -15007, -32332, -4767, 29480, 22432, -16218, -31962, -2290, 30681, 19673, -19696, -30593, 2983, 32234, 14219, -24768, -27128, 10845, 32655, 5501, -29965, -20120, 20310, 29772, -6399, -32748, -8484, 28972, 21276, -19747, -29745, 7227, 32763, 6136, -30323, -18110, 23316, 27012, -13211, -31892, 1697, 32512, 9612, -29253, -19402, 22910, 26767, -14510, -31245, 5116, 32765, 4297, -31575, -12948, 28130, 20279, -22999, -25967, 16771, 29891, -10004, -32103, 3166, 32766, 3372, -32128, -9350, 30461, 14605, -28051, -19067, 25157, 22727, -22015, -25633, 18816, 27861, -15718, -29510, 12834, 30681, -10254, -31480, 8032, 31995, -6211, -32310, 4809, 32487, -3843, -32577, 3316, 32608, -3234, -32595, 3593, 32529, -4396, -32390, 5635, 32132, -7302, -31702, 9376, 31019, -11828, -30000, 14605, 28541, -17636, -26543, 20812, 23901, -23997, -20532, 27008, 16373, -29630, -11411, 31607, 5689, -32666, 662, 32520, -7426, -30915, 14269, 27645, -20761, -22616, 26371, 15874, -30519, -7666, 32615, -1543, -32154, 11047, 28796, -19943, -22483, 27183, 13519, -31710, -2647, 32614, -8968, -29342, 19800, 21875, -28161, -10895, 32456, -2187, -31539, 15306, 25044, -26049, -13669, 32078, -755, -31710, 15419, 24449, -27038, -11389, 32582, -4767, -30161, 20103, 19775, -30404, -3693, 32350, -13828, -24742, 27533, 9269, -32767, 9551, 27187, -25504, -12021, 32689, -7821, -27860, 25070, 12135, -32717, 8779, 27012, -26374, -9624, 32737, -12353, -24331, 28972, 4305, -31935, 18145, 19024, -31736, 3910, 28845, -25094, -10216, 32691, -14431, -21683, 31019, -2306, -29181, 25203, 9200, -32502, 16928, 18744, -32198, 7754, 25724, -29210, -1129, 30118, -24564, -8968, 32281, -19177, -15402, 32752, -13763, -20370, 32107, -8814, -23997, 30873, -4633, -26501, 29480, -1376, -28120, 28251, 893, -29064, 27407, 2158, -29482, 27075, 2420, -29451, 27302, 1681, -28964, 28056, -62, -27935, 29225, -2806, -26203, 30608, -6516, -23553, 31903, -11090, -19747, 32698, -16308, -14574, 32484, -21784, -7929, 30687, -26921, 89, 26753, -30902, 9070, 20279, -32740, 18198, 11197, -31420, 26224, -14, -26141, 31550, -12161, -16666, 32503, -23292, -3693, 27802, -30902, 10875, 17173, -32480, 23961, 1951, -26384, 31842, -14638, -12853, 31255, -27860, 5234, 20910, -32753, 22444, 2872, -26203, 32168, -17048, -9105, 29304, -30689, 12584, 13388, -30912, 29211, -9548, -15878, 31607, -28307, 8156, 16744, -31749, 28251, -8484, -16066, 31422, -29064, 10513, 13780, -30437, 30496, -14130, -9723, 28340, -32017, 19024, 3728, -24490};
            //    int16_t chirp_length = 663;
            //    q15_t chirp[] = {32767, 31856, 29069, 24415, 18043, 10261, 1531, -7537, -16225, -23757, -29367, -32388, -32339, -29013, -22547, -13458, -2635, 8719, 19205, 27399, 32051, 32301, 27863, 19151, 7301, -5927, -18383, -27860, -32506, -31221, -23962, -11880, 2791, 17090, 27907, 32677, 30042, 20305, 5526, -10820, -24609, -32108, -31039, -21363, -5502, 12149, 26374, 32680, 28797, 15607, -2867, -20572, -31363, -31190, -19747, -893, 18485, 30916, 31272, 19030, -1159, -21047, -32088, -29181, -13215, 8911, 27085, 32579, 22383, 1083, -20932, -32425, -27128, -7407, 16462, 31464, 28977, 9976, -14940, -31231, -28920, -8968, 16677, 31987, 26915, 4294, -21313, -32763, -21925, 4179, 27499, 31302, 12411, -15732, -32275, -24422, 2278, 27344, 30878, 9612, -19601, -32763, -18534, 11514, 31793, 24415, -4599, -29628, -27860, -445, 27508, 29609, 3403, -26212, -30248, -4270, 26106, 30042, 3056, -27221, -28904, 253, 29244, 26394, -5633, -31477, -21826, 12810, 32750, 14471, -20970, -31467, -3990, 28441, 25873, -8968, -32607, -14792, 22102, 30364, -1225, -31271, -19494, 18690, 31422, 818, -30996, -19267, 19859, 30584, -2949, -32240, -14031, 25100, 26589, -12235, -32408, -2585, 31311, 16058, -24675, -26011, 14605, 31515, -3264, -32686, -7602, 30301, 16834, -25445, -23883, 19205, 28669, -12512, -31444, 6049, 32624, -262, -32687, -4616, 32078, 8494, -31185, -11383, 30301, 13328, -29642, -14390, 29333, 14605, -29433, -13986, 29921, 12503, -30711, -10112, 31630, 6750, -32430, -2386, 32766, -2949, -32225, 9102, 30333, -15747, -26634, 22322, 20771, -28024, -12635, 31829, 2510, -32624, 8767, 29429, -19747, -21739, 28441, 9897, -32644, 4574, 30499, -18915, -21288, 29480, 6163, -32662, 11452, 26265, -26301, -10961, 32745, -8936, -27128, 26106, 10166, -32757, 11933, 24470, -29044, -3677, 31634, -19747, -16671, 32462, -8680, -25487, 29176, 1531, -30356, 24091, 9612, -32368, 18975, 15270, -32766, 14931, 18717, -32565, 12534, 20279, -32403, 12026, 20161, -32518, 13449, 18347, -32749, 16677, 14605, -32532, 21331, 8607, -30920, 26609, 186, -26692, 31099, -10254, -18684, 32732, -21262, -6433, 29115, -30013, 8911, 18498, -32595, 23785, 1365, -25435, 32360, -17968, -7957, 28645, -31261, 14605, 10780, -29571, 30916, -14465, -10049, 28797, -31689, 17569, 5689, -25828, 32701, -23236, 2493, 19272, -31796, 29552, -13971, -7666, 25781, -32767, 26035, -8744, -11880, 27660, -32706, 25460, -8968, -10569, 26206, -32722, 28241, -14599, -3545, 20383, -30853, 32078, -24041, 9341, 7738, -22547, 31316, -32064, 24918, -11911, -3693, 18251, -28609, 32732, -30040, 21369, -8680, -5453, 18375, -27860, 32444, -31611, 25760, -16052, 4129, 8173, -19132, 27353, -31935, 32514, -29256, 22756, -13926, 3832, 6424, -15849, 23624, -29181, 32201, -32626, 30608, -26478, 20681, -13730, 6147, 1565, -8968, 15695, -21477, 26126, -29549, 31723, -32696, 32555, -31435, 29480, -26855, 23716, -20221, 16505, -12696, 8895, -5191, 1648, 1681, -4764, 7576, -10112, 12365, -14345, 16058, -17521, 18745, -19747, 20539, -21136, 21545, -21776, 21831, -21714, 21419, -20945, 20279, -19414, 18334, -17027, 15476, -13669, 11592, -9239, 6603, -3693, 519, 2890, -6498, 10245, -14061, 17849, -21502, 24886, -27860, 30263, -31939, 32725, -32482, 31088, -28471, 24602, -19534, 13388, -6384, -1176, 8895, -16312, 22911, -28170, 31591, -32767, 31422, -27477, 21078, -12635, 2808, 7512, -17282, 25397, -30831};
            //    int16_t chirp_length = 459;
            //    int16_t chirp[] = {1023, 994, 907, 762, 563, 320, 47, -236, -507, -742, -917, -1012, -1010, -906, -704, -421, -83, 272, 599, 855, 1000, 1008, 869, 597, 227, -186, -574, -870, -1015, -975, -749, -371, 87, 533, 871, 1020, 937, 633, 172, -338, -769, -1003, -970, -667, -172, 379, 823, 1020, 899, 487, -90, -643, -980, -974, -617, -28, 577, 965, 976, 594, -37, -658, -1002, -912, -413, 278, 845, 1017, 698, 33, -654, -1013, -847, -232, 513, 982, 904, 311, -467, -976, -903, -280, 520, 998, 840, 134, -666, -1023, -685, 130, 858, 977, 387, -492, -1008, -763, 71, 853, 964, 300, -612, -1023, -579, 359, 992, 762, -144, -925, -870, -14, 858, 924, 106, -819, -945, -134, 815, 937, 95, -850, -903, 7, 913, 824, -176, -983, -682, 399, 1022, 451, -655, -983, -125, 887, 807, -280, -1018, -462, 690, 947, -39, -977, -609, 583, 981, 25, -968, -602, 620, 954, -93, -1007, -439, 783, 830, -382, -1012, -81, 977, 501, -771, -813, 455, 983, -102, -1021, -238, 946, 525, -795, -746, 599, 895, -391, -982, 188, 1018, -9, -1021, -145, 1001, 265, -974, -356, 946, 416, -926, -450, 915, 455, -919, -437, 934, 390, -959, -316, 987, 210, -1013, -75, 1022, -93, -1007, 284, 947, -492, -832, 696, 648, -875, -395, 993, 78, -1019, 273, 918, -617, -679, 887, 309, -1020, 142, 952, -591, -665, 920, 192, -1020, 357, 820, -822, -343, 1022, -279, -847, 815, 317, -1023, 372, 763, -907, -115, 987, -617, -521, 1013, -271, -796, 910, 47, -948, 752, 300, -1011, 592, 476, -1023, 466, 584, -1017, 391, 633, -1012, 375, 629, -1016, 419, 572, -1023, 520, 455, -1016, 665, 268, -966, 830, 5, -834, 970, -321, -584, 1021, -664, -201, 909, -938, 278, 577, -1018, 742, 42, -795, 1010, -561, -249, 894, -976, 455, 336, -924, 965, -452, -314, 899, -990, 548, 177, -807, 1020, -726, 77, 601, -993, 922, -437, -240, 804, -1023, 812, -273, -371, 863, -1022, 794, -280, -330, 818, -1022, 881, -456, -111, 636, -964, 1001, -751, 291, 241, -704, 977, -1002, 777, -372, -116, 569, -894, 1021, -938, 667, -271, -171, 573, -870, 1012, -987, 804, -502, 128, 255, -598, 853, -998, 1015, -914, 710, -435, 119, 200, -495, 737, -912, 1005, -1019, 955, -827, 645, -429, 191, 48, -280, 490, -671, 815, -923, 990, -1021, 1016, -982, 920, -839, 740, -632, 515, -397, 277, -163, 51, 52, -149, 236, -316, 386, -448, 501, -548, 585, -617, 641, -660, 672, -680, 681, -678, 668, -654, 633, -607, 572, -532, 483, -427, 361, -289, 206, -116, 16, 90, -203, 319, -439, 557, -672, 776, -870, 944, -998, 1021, -1015, 970, -889, 768, -610, 418, -200, -37, 277, -510, 715, -880, 986, -1023, 981, -858, 658, -395, 87, 234, -540, 792, -963};
            //    int16_t chirp_length = 459;

            pingBuffers = completedChannelBuffers[0] == sampleBuffer1a;
            // Perform long buffer analysis
            lastTdoaData = processThreeLongBuffer(
                    completedChannelBuffers[0],
                    completedChannelBuffers[1],
                    completedChannelBuffers[2], conversion->samplesRequestedCount,
                    tjirp, CHIRP_SAMPLE_COUNT);
            GPIO_toggle(LED_ERROR_2);
        }

        startAdcSampling = false;
        sem_post(&adcbufSem);
    }
}

bool allChannelsCompleted(int setCompletedChannel) {
    completedChannels[setCompletedChannel] = true;
    bool syncCompletion = completedChannels[0]
                                            && (completedChannels[1] || NUM_ADC_CHANNELS<2)
                                            && (completedChannels[2] || NUM_ADC_CHANNELS<3);

    // All channels completed, reset
    if (syncCompletion) {
        completedChannels[0]=false;
        completedChannels[1]=false;
        completedChannels[2]=false;
    }
    lastChannelCompleted = setCompletedChannel;
    return syncCompletion;
}

void resetPreambleDetectionHistory()
{
    detection_history_mics[0] = false;
    detection_history_mics[1] = false;
    detection_history_mics[2] = false;
}

bool wasPreambleDetected()
{
    return detection_history_mics[0]
                                  && (detection_history_mics[1] || NUM_ADC_CHANNELS<2)
                                  && (detection_history_mics[2] || NUM_ADC_CHANNELS<3);
}
